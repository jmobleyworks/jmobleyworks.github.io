<!DOCTYPE html>
<html>
<head>
  <style>
    #forest {
      display: none; /* Hide the original image */
    }
    #canvas {
      border: 1px solid black;
    }
    #detectedColor {
      font-family: sans-serif;
      /* Additional styles for displaying the background color visually */
      width: 50px;
      height: 50px;
      border: 1px solid black;
      margin: 10px;
      background-color: #fff; /* Set a default background color */
    }
  </style>
</head>
<body>
  <img id="forest" src="Forest (2).png">
  <canvas id="canvas" width="400" height="400"></canvas>
  <p id="detectedColor"></p>

  <script>
    const image = document.getElementById('forest');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const detectedColorDiv = document.getElementById('detectedColor');
    const numSamples = 100; // Number of random samples

    function getRandomSample(width, height) {
      return {
        x: Math.floor(Math.random() * width),
        y: Math.floor(Math.random() * height),
      };
    }

function estimateBackgroundColor(imageData) {
  const { width, height } = imageData;
  const colorMap = {};
  const maxAttempts = 1000; // Maximum attempts to find a non-black pixel

  for (let i = 0; i < numSamples; i++) {
    let blackPixel = true;
    let attempts = 0;
    while (blackPixel && attempts < maxAttempts) {
      const { x, y } = getRandomSample(width, height);
      const index = (y * width + x) * 4;
      const alpha = imageData.data[index + 3]; // Check alpha channel value
      if (alpha > 220) { // Adjust threshold as needed (consider transparency)
        const red = imageData.data[index];
        const green = imageData.data[index + 1];
        const blue = imageData.data[index + 2];
        if (red > 20 && green > 20 && blue > 20) { // Not black within tolerance
          blackPixel = false;
          const color = `rgb(${red}, ${green}, ${blue})`;
          colorMap[color] = (colorMap[color] || 0) + 1;
        }
      }
      attempts++;
    }
  }

  // Find the color with the highest count (most frequent)
  let maxCount = 0;
  let backgroundColor;
  for (const color in colorMap) {
    if (colorMap[color] > maxCount) {
      maxCount = colorMap[color];
      backgroundColor = color;
    }
  }

  return backgroundColor;
}


      // Find the color with the highest count (most frequent)
      let maxCount = 0;
      let backgroundColor;
      for (const color in colorMap) {
        if (colorMap[color] > maxCount) {
          maxCount = colorMap[color];
          backgroundColor = color;
        }
      }

      return backgroundColor;
    }

    function drawBoundingBoxes(imageData, backgroundColor) {
      const { width, height } = imageData;
      const clearColor = new Color(backgroundColor); // Assuming a Color constructor

      // Clear pixels of the estimated background color (make transparent)
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = (y * width + x) * 4;
          const red = imageData.data[index];
          const green = imageData.data[index + 1];
          const blue = imageData.data[index + 2];
          const currentColor = new Color(red, green, blue); // Assuming a Color constructor
          if (currentColor.近い(clearColor, tolerance)) { // Check color similarity (assuming 近い function)
            imageData.data[index + 3] = 0; // Set alpha to 0 (transparent)
          }
        }
      }

      // Implement your flood fill algorithm and bounding box drawing logic here
      // ... (Replace the commented-out sections with your implementation)
      // This logic should use the modified imageData with transparent background pixels

      // (Optional) Put the modified imageData back onto the canvas for visualization
      // ctx.putImageData(imageData, 0, 0);
    }
    image.onload = function() {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); // Get image data

      // Estimate background color
      const backgroundColor = estimateBackgroundColor(imageData);

      // Draw the original image onto the canvas
      ctx.drawImage(image, 0, 0);

      // Clear pixels of the estimated background color (make transparent)
      drawBoundingBoxes(imageData, backgroundColor);

      // (Optional) Put the modified imageData back onto the canvas for visualization
      // ctx.putImageData(imageData, 0, 0);

      // Update the detected color indicator (assuming a setColor function)
      setColor(detectedColorDiv, backgroundColor);
    };
  </script>
</body>
</html>
