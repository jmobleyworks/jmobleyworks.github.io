<!DOCTYPE html>
<html>
<head>
  <style>
    /* Add your CSS here */
    #forest {
      border: 1px solid black; /* Optional styling for the image */
    }
    #spritesDetected p {
      margin: 5px;
      padding: 5px;
      border: 1px solid lightgray;
      border-radius: 5px; /* Optional styling for detected sprites */
    }
  </style>
</head>
<body>
  <img id="forest" src="Forest (2).png">
  <div id="spritesDetected"></div>

  <script>
    // SpriteDetector class
    class SpriteDetector {
      constructor(image) {
        this.image = image;
        this.sprites = [];
        this.canvas = document.createElement('canvas');
        this.canvas.width = Math.floor(image.width / 2); // Downsample by half
        this.canvas.height = Math.floor(image.height / 2);
        this.ctx = this.canvas.getContext('2d');
        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
        this.imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.threshold = 128; // Adjust threshold value
      }

      detectSprites() {
        const { data, width, height } = this.imageData;

        for (let y = 0; y < height; y++) {
          // Early exit for rows with only transparent pixels (optimization)
          if (this.isRowTransparent(y, data)) continue;

          for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const isNonTransparent = data[index + 3] > 0;

            if (isNonTransparent) {
              let minX = x, maxX = x, minY = y, maxY = y;

              // Find bounding box edges
              while (minX > 0 && isNonTransparent && data[(minY * width + minX - 1) * 4 + 3] > 0) minX--;
              while (maxX < width - 1 && isNonTransparent && data[(minY * width + maxX + 1) * 4 + 3] > 0) maxX++;
              while (minY > 0 && isNonTransparent && data[(minY - 1) * width + x * 4 + 3] > 0) minY--;
              while (maxY < height - 1 && isNonTransparent && data[(maxY + 1) * width + x * 4 + 3] > 0) maxY++;

              // Check for minimum size to avoid noise
              if (maxX - minX + 1 > 4 && maxY - minY + 1 > 4) {
                // Scale bounding box coordinates back to original image size
                const scaledMinX = minX * 2;
                const scaledMinY = minY * 2;
                const scaledMaxX = maxX * 2 + 1;
                const scaledMaxY = maxY * 2 + 1;
                this.sprites.push({ name: `Sprite ${this.sprites.length + 1}`, bounds: [scaledMinX, scaledMinY, scaledMaxX, scaledMaxY] });
              }
            }
          }
        }

        return this.sprites;
      }

      isRowTransparent(y, data) {
        const rowStart = y * this.imageData.width * 4;
        for (let i = rowStart; i < rowStart + this.imageData.width * 4; i += 4) {
          if (data[i + 3] > 0) return false; // Non-transparent pixel found, exit early
        }
        return true;
      }
    }

    window.onload = function() {
      const image = document.getElementById('forest');
      const spriteDetector = new SpriteDetector(image);
      const sprites = spriteDetector.detectSprites();

      // Append detected sprites to the HTML document
      const spritesDetectedDiv = document.getElementById('spritesDetected');
      sprites.forEach(sprite => {
        const p = document.createElement('p');
        p.textContent = `${sprite.name} (X: ${sprite.bounds[0]}, Y: ${sprite.bounds[1]}, W: ${sprite.bounds[2] - sprite.bounds[0] + 1}, H: ${sprite.bounds[3] - sprite.bounds[1] + 1})`;
        spritesDetectedDiv.appendChild(p);
      });
    };
  </script>
</body>
</html>
