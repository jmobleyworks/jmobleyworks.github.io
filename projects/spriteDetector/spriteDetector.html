<!DOCTYPE html>
<body>
  <img id="forest" src="Forest (3).png" style="display: none;">
  <canvas id="canvas" style="border: 1px solid black;"></canvas>
  <p id="detectedColor" style="font-family: sans-serif; width:50px;height:50px;border:1px solid black;margin:10px;"></p>
  <script>
    var tolerance = 10, numSamples = 1, image = document.getElementById('forest'), canvas = document.getElementById('canvas'), detectedColorDiv = document.getElementById('detectedColor'), ctx = canvas.getContext('2d'), backgroundColor = null, seeds = [], boundingBoxes = [], mergedBoxes = [], debug = true;
    let isForeground = (testColor) => { return Math.abs(testColor[0] - backgroundColor[0]) > tolerance || Math.abs(testColor[1] - backgroundColor[1]) > tolerance || Math.abs(testColor[2] - backgroundColor[2]) > tolerance }
    let isBackground = (testColor) => { return Math.abs(testColor[0] - backgroundColor[0]) <= tolerance && Math.abs(testColor[1] - backgroundColor[1]) <= tolerance && Math.abs(testColor[2] - backgroundColor[2]) <= tolerance }
   
    //
    let extractedSprites = [];

let extractSprite = (seed) => {
    if (extractedSprites.some(sprite => isPointInSprite(seed, sprite))) {
        return null; // Skip this seed if it's in an already extracted sprite
    }

    let sprite = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let currentX = seed.x;
    let currentY = seed.y;
    let minX = currentX;
    let minY = currentY;
    let maxX = currentX;
    let maxY = currentY;
    let direction = 0; // 0 = right, 1 = down, 2 = left, 3 = up

    while (true) {
        let currentColor = [
            sprite.data[(currentY * canvas.width + currentX) * 4],
            sprite.data[(currentY * canvas.width + currentX) * 4 + 1],
            sprite.data[(currentY * canvas.width + currentX) * 4 + 2]
        ];

        if (isBackground(currentColor)) {
            // Turn 90 degrees
            direction = (direction + 1) % 4;
        } else {
            // Update bounding box
            minX = Math.min(minX, currentX);
            minY = Math.min(minY, currentY);
            maxX = Math.max(maxX, currentX);
            maxY = Math.max(maxY, currentY);

            // Move forward
            switch (direction) {
                case 0: currentX++; break;
                case 1: currentY++; break;
                case 2: currentX--; break;
                case 3: currentY--; break;
            }

            // Check if we've looped back to the starting point
            if (currentX === seed.x && currentY === seed.y) {
                break;
            }
        }
    }

    // Create a new ImageData object with just the sprite data
    let spriteData = ctx.createImageData(maxX - minX + 1, maxY - minY + 1);
    for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
            let currentColor = [
                sprite.data[(y * canvas.width + x) * 4],
                sprite.data[(y * canvas.width + x) * 4 + 1],
                sprite.data[(y * canvas.width + x) * 4 + 2]
            ];
            if (!isBackground(currentColor)) {
                spriteData.data[((y - minY) * (maxX - minX + 1) + (x - minX)) * 4] = currentColor[0];
                spriteData.data[((y - minY) * (maxX - minX + 1) + (x - minX)) * 4 + 1] = currentColor[1];
                spriteData.data[((y - minY) * (maxX - minX + 1) + (x - minX)) * 4 + 2] = currentColor[2];
                spriteData.data[((y - minY) * (maxX - minX + 1) + (x - minX)) * 4 + 3] = 255;
            }
        }
    }

    extractedSprites.push(spriteData);
    return spriteData;
}

function isPointInSprite(point, sprite) {
    let x = point.x;
    let y = point.y;
    let width = sprite.width;
    let height = sprite.height;
    let data = sprite.data;

    if (x < 0 || y < 0 || x >= width || y >= height) {
        return false; // Point is outside the sprite bounds
    }

    let pixelIndex = (y * width + x) * 4;
    return data[pixelIndex + 3] > 0; // Check if the alpha value is non-zero
}
    //
    
    let drawSprite = (sprite) => {
      var newCanvas = document.createElement('canvas');
      newCanvas.width = sprite.width;
      newCanvas.height = sprite.height;
      newCanvas.getContext('2d').putImageData(sprite, 0, 0);
      var img = document.createElement('img');
      img.src = newCanvas.toDataURL();
      img.width = 100;  // Set the width of the image
      img.height = 100; // Set the height of the image
      document.body.appendChild(img);
    }
    document.getElementById('forest').onload = function() {
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0); // Draw image onto canvas
      backgroundColor = [ctx.getImageData(0, 0, 1, 1).data[0], ctx.getImageData(0, 0, 1, 1).data[1], ctx.getImageData(0, 0, 1, 1).data[2]];
      detectedColorDiv.style.backgroundColor = `rgb(${backgroundColor[0]}, ${backgroundColor[1]}, ${backgroundColor[2]})`;
      seeds = getRandomForegroundSeeds(canvas, isForeground, numSamples);
      if(debug){console.log("seeds.length="+seeds.length);ctx.fillStyle = 'red';seeds.forEach(seed => ctx.fillRect(seed.x, seed.y, 5, 5));}
      seeds.forEach(seed => {drawSprite(extractSprite(seed));});
    };
    function getRandomForegroundSeeds(canvas, isForeground, numSamples) {
      return Array.from({ length: numSamples })
        .map(() => ({ x: Math.floor(Math.random() * canvas.width), y: Math.floor(Math.random() * canvas.height) }))
        .filter(point => isForeground(ctx.getImageData(point.x, point.y, 1, 1).data));
    }
  </script>
</body>
</html>
